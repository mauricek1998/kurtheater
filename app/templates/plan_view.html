{% extends "base.html" %}
{% block content %}
<div class="gh-animate-fade-in">
  <!-- Header mit Titel und Umschalter -->
  <div class="gh-flex gh-justify-between gh-items-center gh-mb-6">
    <h2 class="text-2xl font-semibold">Dienstplan: {{ plan.display_name }}</h2>
  </div>

  <!-- Scrollbare Container f√ºr den Kalender -->
  <div class="gh-overflow-x-auto">
    <div id="calendar" class="gh-min-w-full"></div>
  </div>
  
  <!-- Popup f√ºr Tagesdetails -->
  <div id="dayDetailsPopup" class="gh-popup-overlay">
    <div class="gh-popup">
      <div class="gh-popup-header">
        <h3 class="gh-popup-title" id="popupTitle">Tagesdetails</h3>
        <button class="gh-popup-close" onclick="closeDayDetails()">&times;</button>
      </div>
      <div class="gh-popup-body" id="popupContent">
        <!-- Inhalt wird dynamisch eingef√ºgt -->
      </div>
    </div>
  </div>
  
  {% if is_supervisor %}
  <!-- Speichern-Button (nur f√ºr Supervisoren sichtbar) -->
  <div class="fixed bottom-4 right-4">
    <button id="saveChanges" class="gh-button gh-button-success hidden">
      <span class="octicon octicon-check mr-2"></span>
      √Ñnderungen speichern
    </button>
  </div>
  {% endif %}
  
  <style>
    /* Stile f√ºr die Namensabzeichen */
    .gh-name-badge {
      display: block;
      padding: 4px 6px;
      margin: 2px 0;
      border: 2px solid;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      width: 100%;
      min-height: 24px;
      height: 24px; /* Feste H√∂he f√ºr alle Namensabzeichen */
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
      white-space: normal;
      word-break: break-word;
      overflow-wrap: break-word;
      line-height: 1.1;
      hyphens: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative; /* F√ºr den Bearbeiten-Indikator */
    }
    
    /* Bearbeiten-Indikator f√ºr Supervisoren */
    .gh-name-badge.supervisor-editable::after {
      content: "‚úé";
      position: absolute;
      right: 4px;
      font-size: 10px;
      opacity: 0.7;
    }
    
    .gh-name-badge:hover {
      filter: brightness(1.1);
      box-shadow: 0 0 5px var(--color-accent-fg);
      transform: translateY(-1px);
    }
    
    .gh-name-badge.supervisor-editable:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    /* Stil f√ºr gestrichelte Namensbox (f√ºr fehlende Mitarbeiter) */
    .gh-name-badge-empty {
      display: flex;
      padding: 4px 6px;
      margin: 2px 0;
      border: 2px dashed var(--color-danger-fg);
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      width: 100%;
      min-height: 24px;
      height: 24px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
      align-items: center;
      justify-content: center;
      color: var(--color-danger-fg);
      background-color: rgba(248, 81, 73, 0.1);
    }
    
    .gh-name-badge-empty:hover {
      background-color: rgba(248, 81, 73, 0.2);
      transform: translateY(-1px);
    }
    
    /* Stil f√ºr den Warnindikator (fehlende Mitarbeiter) */
    .gh-warning-indicator {
      position: absolute;
      top: 8px; /* Gleiche H√∂he wie der Notizhinweis */
      right: 40px; /* Rechts statt links, mit Abstand zum Notizhinweis */
      transform: none; /* Entferne die Transformation */
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: transparent; /* Transparent statt ausgef√ºllt */
      border-radius: 50%;
      border: 2px solid var(--color-danger-fg);
      font-size: 16px; /* Gr√∂√üere Schrift */
      font-weight: bold; /* Fett */
      z-index: 3;
      color: var(--color-danger-fg); /* Farbe des Textes anpassen */
      box-shadow: 0 0 8px rgba(248, 81, 73, 0.7);
      animation: pulse-warning 1.5s infinite;
    }
    
    @keyframes pulse-warning {
      0% {
        box-shadow: 0 0 0 0 rgba(248, 81, 73, 0.7);
        transform: scale(1);
      }
      70% {
        box-shadow: 0 0 0 10px rgba(248, 81, 73, 0);
        transform: scale(1.1);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(248, 81, 73, 0);
        transform: scale(1);
      }
    }
    
    /* Stil f√ºr den Notiz-Indikator */
    .gh-note-indicator {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: transparent; /* Transparent statt ausgef√ºllt */
      border-radius: 50%;
      border: 2px solid #FFD700; /* Gelb statt rot */
      font-size: 16px; /* Gr√∂√üere Schrift */
      font-weight: bold; /* Fett */
      z-index: 2;
      color: #FFD700; /* Farbe des Textes anpassen */
      box-shadow: 0 0 5px #FFD700; /* Gelb statt rot */
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.7);
      }
      70% {
        box-shadow: 0 0 0 6px rgba(255, 235, 59, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0);
      }
    }
    
    .gh-note-indicator:hover {
      transform: scale(1.1);
      box-shadow: 0 0 8px rgba(255, 235, 59, 1);
    }
    
    /* Stile f√ºr das Notiz-Popup */
    .gh-note-popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1100;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .gh-note-popup-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    
    .gh-note-popup {
      background-color: var(--color-canvas-default);
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      transform: scale(0.9);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    .gh-note-popup-overlay.active .gh-note-popup {
      transform: scale(1);
      opacity: 1;
    }
    
    .gh-note-popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid var(--color-border-default);
      background-color: var(--color-attention-subtle);
    }
    
    .gh-note-popup-title {
      font-size: 18px;
      font-weight: 600;
      margin: 0;
      color: var(--color-attention-fg);
    }
    
    .gh-note-popup-close {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 20px;
      color: var(--color-fg-muted);
      transition: opacity 0.2s ease;
    }
    
    .gh-note-popup-close:hover {
      opacity: 0.7;
    }
    
    .gh-note-popup-body {
      padding: 16px;
    }
    
    /* Stile f√ºr die Kalenderansicht */
    .gh-calendar-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
    }
    
    @media (min-width: 1200px) {
      .gh-calendar-grid {
        grid-template-columns: repeat(7, minmax(0, 1fr));
      }
    }
    
    @media (max-width: 1199px) and (min-width: 992px) {
      .gh-calendar-grid {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
    }
    
    @media (max-width: 991px) and (min-width: 768px) {
      .gh-calendar-grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }
    
    @media (max-width: 767px) and (min-width: 576px) {
      .gh-calendar-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
    
    @media (max-width: 575px) {
      .gh-calendar-grid {
        grid-template-columns: repeat(1, minmax(0, 1fr));
      }
      
      .gh-hidden-sm {
        display: none !important;
      }
    }
    
    @media (min-width: 576px) and (max-width: 767px) {
      .gh-hidden-md {
        display: none !important;
      }
    }
    
    @media (min-width: 768px) and (max-width: 1199px) {
      .gh-hidden-lg {
        display: none !important;
      }
    }
    
    /* Stil f√ºr Tage, an denen der Benutzer arbeitet */
    .gh-user-working-day {
      border: 2px solid gold !important;
      box-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
    }
    
    .gh-calendar-cell {
      border: 1px solid var(--color-border-default);
      border-radius: 6px;
      background-color: var(--color-canvas-subtle);
      padding: 8px;
      min-height: 100px;
      height: auto;
      display: flex;
      flex-direction: column;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }
    
    .gh-calendar-cell:hover {
      transform: scale(1.02);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    
    .gh-calendar-cell-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      padding-bottom: 4px;
      border-bottom: 1px solid var(--color-border-muted);
      flex-shrink: 0;
    }
    
    .gh-calendar-date {
      font-weight: 600;
      font-size: 16px;
    }
    
    .gh-calendar-weekday {
      font-size: 12px;
      color: var(--color-fg-muted);
    }
    
    .gh-shift-container {
      border-top: 1px solid var(--color-border-muted);
      padding-top: 8px;
      margin-bottom: 12px;
      height: 90px; /* Kleinere H√∂he f√ºr alle Schichtcontainer */
      display: flex;
      flex-direction: column;
      overflow-y: auto; /* Scrollbar bei √úberlauf */
    }
    
    .gh-shift-content {
      flex-grow: 1;
      overflow-y: auto;
    }
    
    .gh-shift-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 4px;
      color: var(--color-accent-fg);
      flex-shrink: 0;
    }
    
    .gh-role-title {
      font-size: 10px;
      font-weight: 600;
      margin-bottom: 2px;
      color: var(--color-fg-muted);
    }
    
    .gh-first-saturday {
      background-color: var(--color-danger-subtle);
      border-color: var(--color-danger-fg);
    }
    
    .gh-first-saturday .gh-calendar-date,
    .gh-first-saturday .gh-calendar-weekday {
      color: var(--color-danger-fg);
    }
    
    /* Stile f√ºr die Stunden√ºbersicht */
    .gh-hours-container {
      margin-top: 24px;
      background-color: var(--color-canvas-subtle);
      border: 1px solid var(--color-border-default);
      border-radius: 6px;
      padding: 16px;
      max-width: 100%;
      overflow-x: auto;
    }
    
    .gh-hours-title {
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      margin-bottom: 16px;
    }
    
    .gh-hours-bar-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      width: 100%;
      min-width: 300px;
    }
    
    .gh-hours-name {
      width: 120px;
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .gh-hours-bar-wrapper {
      flex: 1;
      height: 24px;
      background-color: var(--color-canvas-inset);
      border-radius: 12px;
      position: relative;
    }
    
    .gh-hours-bar {
      height: 100%;
      border-radius: 12px;
      transition: width 0.5s ease;
    }
    
    .gh-hours-value {
      position: absolute;
      right: 8px;
      top: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      font-size: 11px;
      font-weight: 600;
    }
    
    /* Stile f√ºr das Popup */
    .gh-popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .gh-popup-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    
    .gh-popup {
      background-color: var(--color-canvas-default);
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      transform: scale(0.9);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    .gh-popup-overlay.active .gh-popup {
      transform: scale(1);
      opacity: 1;
    }
    
    .gh-popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid var(--color-border-default);
    }
    
    .gh-popup-title {
      font-size: 18px;
      font-weight: 600;
      margin: 0;
    }
    
    .gh-popup-close {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 20px;
      color: var(--color-fg-muted);
      transition: opacity 0.2s ease;
    }
    
    .gh-popup-close:hover {
      opacity: 0.7;
    }
    
    .gh-popup-body {
      padding: 16px;
    }
    
    @media (max-width: 640px) {
      .gh-calendar-grid {
        gap: 4px;
      }
      
      .gh-calendar-cell {
        padding: 4px;
        min-height: 150px;
      }
      
      .gh-calendar-date {
        font-size: 14px;
      }
      
      .gh-shift-title {
        font-size: 10px;
      }
      
      .gh-name-badge {
        font-size: 10px;
        padding: 2px 4px;
        min-height: 20px;
      }
      
      .gh-shift-container {
        height: 70px;
        margin-bottom: 8px;
      }
      
      .gh-hours-name {
        width: 80px;
      }
    }
  </style>
</div>

<script>
  // planData und isSupervisor werden aus Flask als JSON √ºbergeben
  const planData = JSON.parse('{{ plan | tojson | safe }}');
  const isSupervisor = JSON.parse('{{ is_supervisor | tojson | safe }}');
  
  // Notizen-Objekt initialisieren, falls es noch nicht existiert
  if (!planData.notes) {
    planData.notes = {};
  }
  
  // Globale Konstanten f√ºr Monats- und Tagesnamen
  const monthNames = ["Januar", "Februar", "M√§rz", "April", "Mai", "Juni",
                     "Juli", "August", "September", "Oktober", "November", "Dezember"];
  const weekDays = ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"];
  
  // Aus der URL (Query-Parameter) holen wir den Plan-Dateinamen
  const params = new URLSearchParams(window.location.search);
  const planFilename = params.get('plan_filename') || '';
  
  let year, month;
  const match = planFilename.match(/plan_(\d{4})-(\d{2})\.json/);
  if (match) {
    year = parseInt(match[1]);
    month = parseInt(match[2]); // 1-indexiert
  } else {
    const keys = Object.keys(planData.assignments);
    if (keys.length > 0) {
      const parts = keys[0].split("-");
      year = parseInt(parts[0]);
      month = parseInt(parts[1]);
    } else {
      const now = new Date();
      year = now.getFullYear();
      month = now.getMonth() + 1;
    }
  }
  
  // Berechne die minimale Breite anhand des l√§ngsten Mitarbeiternamens
  let maxNameLength = 0;
  for (const name in planData.total_hours) {
    if (name.length > maxNameLength) {
      maxNameLength = name.length;
    }
  }
  
  // Erzeuge ein Mapping f√ºr Mitarbeiterfarben
  const defaultColors = ["#7FB3D5", "#F5B041", "#82E0AA", "#F1948A", "#BB8FCE", "#85C1E9", "#F7DC6F", "#F0B27A"];
  const employeeColors = {};
  let colorIndex = 0;
  
  // Funktion zum Generieren einer zuf√§lligen Pastellfarbe
  function generatePastelColor() {
    const hue = Math.floor(Math.random() * 360);
    return `hsl(${hue}, 70%, 80%)`;
  }
  
  // Funktion zum Zuweisen einer Farbe
  function getEmployeeColor(name) {
    if (!employeeColors[name]) {
      if (colorIndex < defaultColors.length) {
        employeeColors[name] = defaultColors[colorIndex++];
      } else {
        employeeColors[name] = generatePastelColor();
      }
    }
    return employeeColors[name];
  }
  
  // Initialisiere die Farben f√ºr alle bekannten Mitarbeiter
  for (const name in planData.total_hours) {
    getEmployeeColor(name);
  }
  
  // Tracking f√ºr Namens√§nderungen
  let pendingChanges = new Map();
  const saveButton = document.getElementById('saveChanges');
  
  // Funktion zum Erstellen eines bearbeitbaren Namens-Spans
  function createEditableNameSpan(name, originalColor, date, shift, role) {
    const span = document.createElement('div'); // Verwende div statt span f√ºr bessere Blockdarstellung
    span.textContent = name;
    span.className = 'gh-name-badge';
    span.dataset.role = role;
    
    // Verwende Outline-Stil statt Hintergrundfarbe
    span.style.borderColor = originalColor;
    span.style.color = originalColor;
    
    if (isSupervisor) {
      span.title = "Klicken zum Bearbeiten";
      span.classList.add('supervisor-editable'); // Klasse f√ºr Bearbeiten-Indikator
      
      // Funktion zum Bearbeiten des Namens
      function editName() {
        const input = document.createElement('input');
        input.type = 'text';
        input.value = span.textContent;
        input.className = 'gh-form-control gh-w-full';
        input.style.minWidth = maxNameLength + "ch";
        
        input.addEventListener('blur', async function() {
          const newName = input.value.trim();
          if (newName && newName !== name) {
            try {
              const response = await fetch('/update_plan_name', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  plan_filename: planFilename,
                  old_name: name,
                  new_name: newName,
                  date: date,
                  shift: shift,
                  role: role
                })
              });
              
              if (response.ok) {
                span.textContent = newName;
                const newColor = getEmployeeColor(newName);
                span.style.borderColor = newColor;
                span.style.color = newColor;
                location.reload(); // Seite neu laden, um die aktualisierten Stunden zu sehen
              } else {
                const error = await response.json();
                alert(`Fehler beim Speichern: ${error.error}`);
                span.textContent = name;
                span.style.borderColor = originalColor;
                span.style.color = originalColor;
              }
            } catch (error) {
              alert(`Fehler beim Speichern: ${error.message}`);
              span.textContent = name;
              span.style.borderColor = originalColor;
              span.style.color = originalColor;
            }
          } else {
            span.textContent = name;
            span.style.borderColor = originalColor;
            span.style.color = originalColor;
          }
          span.style.display = 'block'; // Blockdarstellung wiederherstellen
        });
        
        input.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            input.blur();
          }
        });
        
        span.style.display = 'none';
        span.parentNode.insertBefore(input, span);
        input.focus();
      }
      
      // Einfacher Klick zum Bearbeiten
      span.addEventListener('click', editName);
      
      // Doppelklick zum Bearbeiten (als Fallback)
      span.addEventListener('dblclick', editName);
    }
    
    return span;
  }
  
  // Funktion zum Speichern der √Ñnderungen
  async function saveChanges() {
    for (const [oldName, newName] of pendingChanges) {
      try {
        const response = await fetch('/update_plan_name', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            plan_filename: planFilename,
            old_name: oldName,
            new_name: newName
          })
        });
        
        if (response.ok) {
          // Aktualisiere die Farbe auf die des neuen Namens
          const newColor = getEmployeeColor(newName);
          document.querySelectorAll(`span[data-original-name="${oldName}"]`).forEach(span => {
            span.style.borderColor = newColor;
            span.style.color = newColor;
            span.dataset.originalName = newName;
          });
        } else {
          const error = await response.json();
          alert(`Fehler beim Speichern: ${error.error}`);
        }
      } catch (error) {
        alert(`Fehler beim Speichern: ${error.message}`);
      }
    }
    
    pendingChanges.clear();
    saveButton.classList.add('hidden');
    location.reload(); // Seite neu laden, um alle √Ñnderungen zu sehen
  }
  
  // Funktion zum Anzeigen der Tagesdetails
  function showDayDetails(dateStr) {
    const popup = document.getElementById('dayDetailsPopup');
    const popupTitle = document.getElementById('popupTitle');
    const popupContent = document.getElementById('popupContent');
    
    // Datum formatieren
    const dateParts = dateStr.split('-');
    const year = parseInt(dateParts[0]);
    const month = parseInt(dateParts[1]);
    const day = parseInt(dateParts[2]);
    const date = new Date(year, month - 1, day);
    const dayName = weekDays[date.getDay()];
    
    // Titel setzen
    popupTitle.textContent = `${day}. ${monthNames[month - 1]} ${year} (${dayName})`;
    
    // Inhalt leeren
    popupContent.innerHTML = '';
    
    // Pr√ºfen, ob es Schichten f√ºr diesen Tag gibt
    if (!planData.assignments[dateStr]) {
      popupContent.innerHTML = '<p class="gh-text-muted">Keine Schichten f√ºr diesen Tag.</p>';
      popup.classList.add('active');
      return;
    }
    
    // Notiz-Button hinzuf√ºgen (nur f√ºr Supervisoren)
    if (isSupervisor) {
      const noteButtonContainer = document.createElement('div');
      noteButtonContainer.className = 'gh-flex gh-justify-end gh-mb-4';
      
      const noteButton = document.createElement('button');
      noteButton.className = 'gh-button gh-button-sm gh-button-outline';
      
      // Pr√ºfen, ob es bereits eine Notiz f√ºr diesen Tag gibt
      const hasNote = planData.notes && 
                     planData.notes[dateStr] && 
                     planData.notes[dateStr].day && 
                     planData.notes[dateStr].day.trim() !== '';
      
      if (hasNote) {
        noteButton.innerHTML = '<span class="octicon octicon-pencil mr-1"></span>Notiz bearbeiten';
        noteButton.classList.add('gh-button-attention');
      } else {
        noteButton.innerHTML = '<span class="octicon octicon-plus mr-1"></span>Notiz hinzuf√ºgen';
      }
      
      noteButton.addEventListener('click', function() {
        showNotePopup(dateStr);
      });
      
      noteButtonContainer.appendChild(noteButton);
      popupContent.appendChild(noteButtonContainer);
    }
    
    // Notiz anzeigen, falls vorhanden
    if (planData.notes && planData.notes[dateStr] && planData.notes[dateStr].day && planData.notes[dateStr].day.trim() !== '') {
      const noteContainer = document.createElement('div');
      noteContainer.className = 'gh-p-3 gh-mb-4 gh-bg-attention-subtle gh-rounded border border-[var(--color-attention-fg)]';
      
      const noteHeader = document.createElement('div');
      noteHeader.className = 'gh-flex gh-items-center gh-mb-2';
      
      const noteIcon = document.createElement('span');
      noteIcon.className = 'text-attention-fg mr-2 font-bold';
      noteIcon.textContent = '!'; // Ausrufezeichen statt Icon
      noteHeader.appendChild(noteIcon);
      
      const noteLabel = document.createElement('div');
      noteLabel.className = 'font-medium text-attention-fg';
      noteLabel.textContent = 'Notiz:';
      noteHeader.appendChild(noteLabel);
      
      noteContainer.appendChild(noteHeader);
      
      const noteText = document.createElement('div');
      noteText.className = 'gh-text-small gh-whitespace-pre-wrap';
      noteText.textContent = planData.notes[dateStr].day;
      noteContainer.appendChild(noteText);
      
      popupContent.appendChild(noteContainer);
    }
    
    // Schichten anzeigen
    const shifts = ['mittags', 'nachmittags', 'abends'];
    shifts.forEach(shiftKey => {
      const shiftContainer = document.createElement('div');
      shiftContainer.className = 'gh-mb-4';
      
      const shiftTitle = document.createElement('h4');
      shiftTitle.className = 'font-semibold text-lg gh-mb-2';
      shiftTitle.textContent = shiftKey;
      shiftContainer.appendChild(shiftTitle);
      
      if (planData.assignments[dateStr][shiftKey]) {
        const assignment = planData.assignments[dateStr][shiftKey];
        
        // Pr√ºfe, ob es eine normale oder SV-Schicht ist
        if (assignment.Vorfuehrer !== undefined) {
          // Normale Schicht mit Vorf√ºhrer und Bistro
          const rolesContainer = document.createElement('div');
          rolesContainer.className = 'gh-flex gh-flex-col gh-gap-2';
          
          // Vorf√ºhrer
          const vfContainer = document.createElement('div');
          const vfTitle = document.createElement('div');
          vfTitle.textContent = 'Vorf√ºhrer:';
          vfTitle.className = 'font-medium';
          vfContainer.appendChild(vfTitle);
          
          // Pr√ºfe, ob ein Vorf√ºhrer zugewiesen ist
          if (assignment.Vorfuehrer && assignment.Vorfuehrer.trim() !== '') {
            const vfName = createEditableNameSpan(assignment.Vorfuehrer, getEmployeeColor(assignment.Vorfuehrer), dateStr, shiftKey, 'Vorfuehrer');
            vfContainer.appendChild(vfName);
          } else {
            // Leere Box f√ºr fehlenden Vorf√ºhrer
            const emptyVfBadge = createEmptyNameBadge(dateStr, shiftKey, 'Vorfuehrer');
            vfContainer.appendChild(emptyVfBadge);
          }
          
          rolesContainer.appendChild(vfContainer);
          
          // Bistro
          const bistroContainer = document.createElement('div');
          const bistroTitle = document.createElement('div');
          bistroTitle.textContent = 'Bistro:';
          bistroTitle.className = 'font-medium';
          bistroContainer.appendChild(bistroTitle);
          
          const bistroNamesContainer = document.createElement('div');
          bistroNamesContainer.className = 'gh-flex gh-flex-col gh-gap-2';
          
          // Pr√ºfe, ob Bistro-Mitarbeiter zugewiesen sind
          if (typeof assignment.Bistro === 'string') {
            if (assignment.Bistro && assignment.Bistro.trim() !== '') {
              const bistroName = createEditableNameSpan(assignment.Bistro, getEmployeeColor(assignment.Bistro), dateStr, shiftKey, 'Bistro');
              bistroNamesContainer.appendChild(bistroName);
            }
            
            // F√ºge eine leere Box hinzu, wenn weniger als 2 Bistro-Mitarbeiter
            bistroNamesContainer.appendChild(createEmptyNameBadge(dateStr, shiftKey, 'Bistro', 1));
          } else if (Array.isArray(assignment.Bistro)) {
            // Zeige vorhandene Bistro-Mitarbeiter
            assignment.Bistro.forEach((emp, index) => {
              if (emp && emp.trim() !== '') {
                const empName = createEditableNameSpan(emp, getEmployeeColor(emp), dateStr, shiftKey, `Bistro[${index}]`);
                bistroNamesContainer.appendChild(empName);
              }
            });
            
            // F√ºge leere Boxen hinzu, wenn weniger als 2 Bistro-Mitarbeiter
            const filledBistroCount = assignment.Bistro.filter(name => name && name.trim() !== '').length;
            for (let i = filledBistroCount; i < 2; i++) {
              bistroNamesContainer.appendChild(createEmptyNameBadge(dateStr, shiftKey, 'Bistro', i));
            }
          } else {
            // Keine Bistro-Mitarbeiter zugewiesen, f√ºge 2 leere Boxen hinzu
            bistroNamesContainer.appendChild(createEmptyNameBadge(dateStr, shiftKey, 'Bistro', 0));
            bistroNamesContainer.appendChild(createEmptyNameBadge(dateStr, shiftKey, 'Bistro', 1));
          }
          
          bistroContainer.appendChild(bistroNamesContainer);
          rolesContainer.appendChild(bistroContainer);
          shiftContainer.appendChild(rolesContainer);
        } else {
          // SV-Schicht (nur Bistro)
          const svContainer = document.createElement('div');
          const svTitle = document.createElement('div');
          svTitle.textContent = 'Bistro (SV):';
          svTitle.className = 'font-medium';
          svContainer.appendChild(svTitle);
          
          const bistroNamesContainer = document.createElement('div');
          bistroNamesContainer.className = 'gh-flex gh-flex-col gh-gap-2';
          
          // Pr√ºfe, ob Bistro-Mitarbeiter zugewiesen sind
          if (typeof assignment.Bistro === 'string') {
            if (assignment.Bistro && assignment.Bistro.trim() !== '') {
              const bistroName = createEditableNameSpan(assignment.Bistro, getEmployeeColor(assignment.Bistro), dateStr, shiftKey, 'Bistro');
              bistroNamesContainer.appendChild(bistroName);
            }
            
            // F√ºge eine leere Box hinzu, wenn weniger als 2 Bistro-Mitarbeiter
            bistroNamesContainer.appendChild(createEmptyNameBadge(dateStr, shiftKey, 'Bistro', 1));
          } else if (Array.isArray(assignment.Bistro)) {
            // Zeige vorhandene Bistro-Mitarbeiter
            assignment.Bistro.forEach((emp, index) => {
              if (emp && emp.trim() !== '') {
                const empName = createEditableNameSpan(emp, getEmployeeColor(emp), dateStr, shiftKey, `Bistro[${index}]`);
                bistroNamesContainer.appendChild(empName);
              }
            });
            
            // F√ºge leere Boxen hinzu, wenn weniger als 2 Bistro-Mitarbeiter
            const filledBistroCount = assignment.Bistro.filter(name => name && name.trim() !== '').length;
            for (let i = filledBistroCount; i < 2; i++) {
              bistroNamesContainer.appendChild(createEmptyNameBadge(dateStr, shiftKey, 'Bistro', i));
            }
          } else {
            // Keine Bistro-Mitarbeiter zugewiesen, f√ºge 2 leere Boxen hinzu
            bistroNamesContainer.appendChild(createEmptyNameBadge(dateStr, shiftKey, 'Bistro', 0));
            bistroNamesContainer.appendChild(createEmptyNameBadge(dateStr, shiftKey, 'Bistro', 1));
          }
          
          svContainer.appendChild(bistroNamesContainer);
          shiftContainer.appendChild(svContainer);
        }
      } else {
        // Keine Schicht f√ºr diesen Tag/Schichttyp
        const noShift = document.createElement('div');
        noShift.textContent = 'Keine Schicht';
        noShift.className = 'gh-text-small gh-text-muted';
        shiftContainer.appendChild(noShift);
      }
      
      popupContent.appendChild(shiftContainer);
    });
    
    // Popup anzeigen
    popup.classList.add('active');
  }
  
  // Funktion zum Anzeigen des Notiz-Popups
  function showNotePopup(dateStr) {
    // Datum formatieren
    const dateParts = dateStr.split('-');
    const year = parseInt(dateParts[0]);
    const month = parseInt(dateParts[1]);
    const day = parseInt(dateParts[2]);
    const date = new Date(year, month - 1, day);
    const dayName = weekDays[date.getDay()];
    
    // Erstelle das Popup, falls es noch nicht existiert
    let notePopup = document.getElementById('notePopupOverlay');
    if (!notePopup) {
      notePopup = document.createElement('div');
      notePopup.id = 'notePopupOverlay';
      notePopup.className = 'gh-note-popup-overlay';
      
      const notePopupContent = document.createElement('div');
      notePopupContent.className = 'gh-note-popup';
      
      const notePopupHeader = document.createElement('div');
      notePopupHeader.className = 'gh-note-popup-header';
      
      const notePopupTitle = document.createElement('h3');
      notePopupTitle.id = 'notePopupTitle';
      notePopupTitle.className = 'gh-note-popup-title';
      notePopupHeader.appendChild(notePopupTitle);
      
      const notePopupClose = document.createElement('button');
      notePopupClose.className = 'gh-note-popup-close';
      notePopupClose.innerHTML = '&times;';
      notePopupClose.onclick = closeNotePopup;
      notePopupHeader.appendChild(notePopupClose);
      
      notePopupContent.appendChild(notePopupHeader);
      
      const notePopupBody = document.createElement('div');
      notePopupBody.id = 'notePopupBody';
      notePopupBody.className = 'gh-note-popup-body';
      notePopupContent.appendChild(notePopupBody);
      
      notePopup.appendChild(notePopupContent);
      document.body.appendChild(notePopup);
      
      // Schlie√üen des Popups beim Klick auf den Hintergrund
      notePopup.addEventListener('click', function(event) {
        if (event.target === this) {
          closeNotePopup();
        }
      });
    }
    
    // Aktualisiere den Titel
    const notePopupTitle = document.getElementById('notePopupTitle');
    notePopupTitle.textContent = `Notiz f√ºr ${day}. ${monthNames[month - 1]} ${year} (${dayName})`;
    
    // Aktualisiere den Inhalt
    const notePopupBody = document.getElementById('notePopupBody');
    notePopupBody.innerHTML = '';
    
    // Aktuelle Notiz abrufen
    const currentNote = planData.notes && 
                       planData.notes[dateStr] && 
                       planData.notes[dateStr].day 
                       ? planData.notes[dateStr].day 
                       : '';
    
    const noteTextarea = document.createElement('textarea');
    noteTextarea.className = 'gh-form-control gh-w-full';
    noteTextarea.rows = 6;
    noteTextarea.placeholder = 'Notiz f√ºr diesen Tag hinzuf√ºgen...';
    noteTextarea.value = currentNote;
    notePopupBody.appendChild(noteTextarea);
    
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'gh-flex gh-justify-end gh-mt-4 gh-gap-2';
    
    const cancelButton = document.createElement('button');
    cancelButton.className = 'gh-button gh-button-outline';
    cancelButton.innerHTML = '<span class="octicon octicon-x mr-1"></span>Abbrechen';
    cancelButton.addEventListener('click', closeNotePopup);
    buttonContainer.appendChild(cancelButton);
    
    const saveNoteButton = document.createElement('button');
    saveNoteButton.className = 'gh-button gh-button-success';
    saveNoteButton.innerHTML = '<span class="octicon octicon-check mr-1"></span>Speichern';
    saveNoteButton.addEventListener('click', async function() {
      const success = await saveNote(dateStr, 'day', noteTextarea.value);
      if (success) {
        closeNotePopup();
        // Aktualisiere die Tagesdetails-Ansicht
        showDayDetails(dateStr);
      }
    });
    buttonContainer.appendChild(saveNoteButton);
    
    notePopupBody.appendChild(buttonContainer);
    
    // Popup anzeigen
    notePopup.classList.add('active');
    
    // Fokus auf das Textarea setzen
    setTimeout(() => {
      noteTextarea.focus();
    }, 300);
  }
  
  // Funktion zum Schlie√üen des Notiz-Popups
  function closeNotePopup() {
    const notePopup = document.getElementById('notePopupOverlay');
    if (notePopup) {
      notePopup.classList.remove('active');
    }
  }
  
  // Funktion zum Speichern einer Notiz
  async function saveNote(dateStr, key, note) {
    try {
      const response = await fetch('/update_plan_note', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          plan_filename: planFilename,
          date: dateStr,
          key: key,
          note: note
        })
      });
      
      if (response.ok) {
        // Notiz im lokalen Objekt aktualisieren
        if (!planData.notes[dateStr]) {
          planData.notes[dateStr] = {};
        }
        planData.notes[dateStr][key] = note;
        
        // Aktualisiere die Anzeige in der Kalenderansicht
        updateNoteIndicator(dateStr);
        
        return true;
      } else {
        const error = await response.json();
        alert(`Fehler beim Speichern der Notiz: ${error.error}`);
        return false;
      }
    } catch (error) {
      alert(`Fehler beim Speichern der Notiz: ${error.message}`);
      return false;
    }
  }
  
  // Funktion zum Aktualisieren des Notiz-Indikators in der Kalenderansicht
  function updateNoteIndicator(dateStr) {
    const cell = document.querySelector(`.gh-calendar-cell[data-date="${dateStr}"]`);
    if (!cell) return;
    
    // Pr√ºfe, ob es Notizen f√ºr diesen Tag gibt
    let hasNotes = false;
    if (planData.notes[dateStr] && planData.notes[dateStr].day && planData.notes[dateStr].day.trim() !== '') {
      hasNotes = true;
    }
    
    // Entferne vorhandenen Indikator, falls vorhanden
    const existingIndicator = cell.querySelector('.gh-note-indicator');
    if (existingIndicator) {
      existingIndicator.remove();
    }
    
    // F√ºge Indikator hinzu, wenn Notizen vorhanden sind
    if (hasNotes) {
      const noteIndicator = document.createElement('div');
      noteIndicator.className = 'gh-note-indicator';
      noteIndicator.innerHTML = '!'; // Ausrufezeichen statt Icon
      noteIndicator.title = 'Notiz vorhanden';
      
      // F√ºge den Indikator direkt in die Zelle ein (absolute Positionierung)
      cell.appendChild(noteIndicator);
    }
  }
  
  // Funktion zum Pr√ºfen, ob die Mindestanzahl an Mitarbeitern f√ºr eine Schicht erreicht ist
  function checkMinimumStaffing(dateStr) {
    if (!planData.assignments[dateStr]) return true; // Keine Schicht, kein Problem
    
    let isFullyStaffed = true;
    const shifts = ['mittags', 'nachmittags', 'abends'];
    
    for (const shiftKey of shifts) {
      if (!planData.assignments[dateStr][shiftKey]) continue; // Keine Schicht zu dieser Zeit
      
      const assignment = planData.assignments[dateStr][shiftKey];
      
      // Pr√ºfe, ob es eine normale oder SV-Schicht ist
      const isSVShift = assignment.Vorfuehrer === undefined;
      
      // Pr√ºfe Vorf√ºhrer (nur f√ºr normale Schichten)
      if (!isSVShift && (!assignment.Vorfuehrer || assignment.Vorfuehrer.trim() === '')) {
        isFullyStaffed = false;
      }
      
      // Pr√ºfe Bistro (f√ºr alle Schichten)
      let bistroPeople = 0;
      if (typeof assignment.Bistro === 'string' && assignment.Bistro.trim() !== '') {
        bistroPeople = 1;
      } else if (Array.isArray(assignment.Bistro)) {
        bistroPeople = assignment.Bistro.filter(name => name && name.trim() !== '').length;
      }
      
      // Mindestens 2 Bistro-Mitarbeiter erforderlich
      if (bistroPeople < 2) {
        isFullyStaffed = false;
      }
    }
    
    return isFullyStaffed;
  }
  
  // Funktion zum Erstellen einer leeren Namensbox f√ºr fehlende Mitarbeiter
  function createEmptyNameBadge(dateStr, shiftKey, role, index = null) {
    const emptyBadge = document.createElement('div');
    emptyBadge.className = 'gh-name-badge-empty';
    
    if (isSupervisor) {
      // F√ºr Supervisoren: "Mitarbeiter hinzuf√ºgen" mit Klick-Funktion
      emptyBadge.textContent = 'Mitarbeiter hinzuf√ºgen';
      emptyBadge.addEventListener('click', function() {
        addNewEmployee(dateStr, shiftKey, role, index);
      });
    } else {
      // F√ºr normale Benutzer: Nur ein Fragezeichen
      emptyBadge.textContent = '?';
      emptyBadge.style.cursor = 'not-allowed';
      emptyBadge.title = 'Nur Supervisoren k√∂nnen Mitarbeiter hinzuf√ºgen';
    }
    
    return emptyBadge;
  }
  
  // Funktion zum Hinzuf√ºgen eines neuen Mitarbeiters
  async function addNewEmployee(dateStr, shiftKey, role, index = null) {
    // Erstelle ein Popup zur Eingabe des Namens
    const nameInput = prompt('Name des Mitarbeiters eingeben:');
    
    if (!nameInput || nameInput.trim() === '') return;
    
    try {
      // Bestimme den genauen Rollenparameter basierend auf dem Index
      let exactRole = role;
      if (role === 'Bistro' && index !== null) {
        exactRole = `Bistro[${index}]`;
      }
      
      // Bereite die Daten f√ºr die Anfrage vor
      const requestData = {
        plan_filename: planFilename,
        old_name: '', // Leerer String f√ºr neue Mitarbeiter
        new_name: nameInput.trim(),
        date: dateStr,
        shift: shiftKey,
        role: exactRole
      };
      
      console.log('Sende Anfrage mit Daten:', requestData);
      
      const response = await fetch('/update_plan_name', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData)
      });
      
      if (response.ok) {
        // Seite neu laden, um die √Ñnderungen zu sehen
        location.reload();
      } else {
        const errorData = await response.json();
        console.error('Server-Fehler:', errorData);
        alert(`Fehler beim Speichern: ${errorData.error || 'Unbekannter Fehler'}`);
      }
    } catch (error) {
      console.error('Client-Fehler:', error);
      alert(`Fehler beim Speichern: ${error.message}`);
    }
  }
  
  if (isSupervisor) {
    saveButton.addEventListener('click', saveChanges);
  }
  
  // Hilfsfunktion: Generiert den Kalender
  function generateCalendar(year, month, assignments) {
    const calendarContainer = document.getElementById('calendar');
    calendarContainer.innerHTML = '';
    
    // Funktion zum Finden des ersten Samstags im Monat
    function isFirstSaturday(date) {
      return date.getDay() === 6 && // Samstag
             date.getDate() <= 7;   // Erster Samstag (innerhalb der ersten 7 Tage)
    }
    
    // Funktion zum Pr√ºfen, ob der aktuelle Benutzer an diesem Tag arbeitet
    function isUserWorkingDay(dateStr) {
      const currentUser = '{{ current_user.name }}';
      if (!assignments[dateStr]) return false;
      
      for (const shiftKey in assignments[dateStr]) {
        const shift = assignments[dateStr][shiftKey];
        if (!shift) continue;
        
        // Pr√ºfe, ob der Benutzer als Vorf√ºhrer arbeitet
        if (shift.Vorfuehrer && shift.Vorfuehrer.trim() === currentUser.trim()) {
          return true;
        }
        
        // Pr√ºfe, ob der Benutzer im Bistro arbeitet
        if (typeof shift.Bistro === 'string' && shift.Bistro.trim() === currentUser.trim()) {
          return true;
        } else if (Array.isArray(shift.Bistro) && shift.Bistro.some(name => name.trim() === currentUser.trim())) {
          return true;
        }
      }
      
      return false;
    }
    
    // Monats√ºberschrift
    const header = document.createElement('h2');
    header.textContent = monthNames[month - 1] + " " + year;
    header.className = "text-2xl font-semibold text-center gh-mb-4";
    calendarContainer.appendChild(header);
    
    // Wochentage-Header
    const weekHeader = document.createElement('div');
    weekHeader.className = "gh-calendar-grid gh-mb-2";
    weekDays.forEach(day => {
      const dayDiv = document.createElement('div');
      dayDiv.textContent = day;
      dayDiv.className = "text-center font-semibold gh-p-2 text-sm";
      weekHeader.appendChild(dayDiv);
    });
    calendarContainer.appendChild(weekHeader);
    
    // Berechne die Anzahl der Wochen im Monat
    const firstDate = new Date(year, month - 1, 1);
    const startingDay = firstDate.getDay();
    const daysInMonth = new Date(year, month, 0).getDate();
    const totalDays = startingDay + daysInMonth;
    const totalWeeks = Math.ceil(totalDays / 7);
    
    // Erstelle f√ºr jede Woche ein eigenes Grid
    for (let week = 0; week < totalWeeks; week++) {
      // Wochengrid
      const weekGrid = document.createElement('div');
      weekGrid.className = "gh-calendar-grid gh-mb-4";
      
      // Tage in dieser Woche
      for (let dayOfWeek = 0; dayOfWeek < 7; dayOfWeek++) {
        const dayIndex = week * 7 + dayOfWeek - startingDay + 1;
        
        // Leere Zelle f√ºr Tage au√üerhalb des Monats
        if (dayIndex <= 0 || dayIndex > daysInMonth) {
          const emptyCell = document.createElement('div');
          emptyCell.className = "gh-calendar-cell gh-opacity-50";
          weekGrid.appendChild(emptyCell);
          continue;
        }
        
        const day = dayIndex;
        const dayStr = day < 10 ? "0" + day : "" + day;
        const monthStr = month < 10 ? "0" + month : "" + month;
        const dateStr = year + "-" + monthStr + "-" + dayStr;
        const currentDate = new Date(year, month - 1, day);
        
        const cell = document.createElement('div');
        const isFirstSat = isFirstSaturday(currentDate);
        const isWorkingDay = isUserWorkingDay(dateStr);
        
        cell.className = `gh-calendar-cell ${isFirstSat ? 'gh-first-saturday' : ''} ${isWorkingDay ? 'gh-user-working-day' : ''}`;
        cell.dataset.date = dateStr;
        
        // Zellenheader mit Datum und Wochentag
        const cellHeader = document.createElement('div');
        cellHeader.className = "gh-calendar-cell-header";
        
        const dateInfo = document.createElement('div');
        
        const dateSpan = document.createElement('span');
        dateSpan.textContent = day;
        dateSpan.className = "gh-calendar-date";
        dateInfo.appendChild(dateSpan);
        
        const weekdaySpan = document.createElement('span');
        weekdaySpan.textContent = " " + weekDays[currentDate.getDay()];
        weekdaySpan.className = "gh-calendar-weekday";
        dateInfo.appendChild(weekdaySpan);
        
        cellHeader.appendChild(dateInfo);
        
        // F√ºge das traurige Emoji f√ºr den ersten Samstag hinzu
        if (isFirstSat) {
          const sadEmoji = document.createElement('div');
          sadEmoji.className = "text-lg";
          sadEmoji.textContent = "üò¢";
          sadEmoji.title = "Erster Samstag im Monat";
          cellHeader.appendChild(sadEmoji);
        }
        
        cell.appendChild(cellHeader);
        
        // F√ºge Indikator f√ºr Schichten hinzu, wenn der Benutzer an diesem Tag arbeitet
        if (isWorkingDay) {
          const shiftsIndicator = document.createElement('div');
          shiftsIndicator.className = "gh-text-center gh-mt-2";
          shiftsIndicator.innerHTML = '<span class="octicon octicon-calendar-check text-success-fg text-xl"></span>';
          shiftsIndicator.title = "Du arbeitest an diesem Tag";
          cell.appendChild(shiftsIndicator);
        }
        
        // Pr√ºfe, ob die Mindestanzahl an Mitarbeitern erreicht ist
        const isFullyStaffed = checkMinimumStaffing(dateStr);
        
        // F√ºge Warnindikator hinzu, wenn die Mindestanzahl nicht erreicht ist (nur f√ºr Supervisoren)
        if (!isFullyStaffed && isSupervisor) {
          const warningIndicator = document.createElement('div');
          warningIndicator.className = 'gh-warning-indicator';
          warningIndicator.innerHTML = '!';
          warningIndicator.title = 'Mindestanzahl an Mitarbeitern nicht erreicht';
          cell.appendChild(warningIndicator);
        }
        
        // F√ºge Indikator f√ºr Notizen hinzu, wenn vorhanden
        if (planData.notes && planData.notes[dateStr] && planData.notes[dateStr].day && planData.notes[dateStr].day.trim() !== '') {
          const noteIndicator = document.createElement('div');
          noteIndicator.className = 'gh-note-indicator';
          noteIndicator.innerHTML = '!';
          noteIndicator.title = 'Notiz vorhanden';
          cell.appendChild(noteIndicator);
        }
        
        // Event-Listener f√ºr Klick auf Zelle
        cell.addEventListener('click', function() {
          showDayDetails(dateStr);
        });
        
        weekGrid.appendChild(cell);
      }
      
      calendarContainer.appendChild(weekGrid);
    }
    
    // Stundenliste als Balkendiagramm - nur f√ºr Supervisoren anzeigen
    if (isSupervisor) {
      const hoursContainer = document.createElement('div');
      hoursContainer.className = "gh-hours-container";
      
      const hoursTitle = document.createElement('h3');
      hoursTitle.textContent = "Arbeitsstunden pro Mitarbeiter";
      hoursTitle.className = "gh-hours-title";
      hoursContainer.appendChild(hoursTitle);
      
      // Sortiere die Mitarbeiter nach Stunden
      const sortedEmployees = Object.entries(planData.total_hours)
        .sort(([,a], [,b]) => b - a);
      
      // Finde die maximalen Stunden f√ºr die Skalierung
      const maxHours = sortedEmployees.length > 0 ? sortedEmployees[0][1] : 0;
      
      const chartContainer = document.createElement('div');
      chartContainer.className = "gh-flex gh-flex-col gh-gap-2";
      
      sortedEmployees.forEach(([name, hours], index) => {
        const barContainer = document.createElement('div');
        barContainer.className = "gh-hours-bar-container";
        
        // Name
        const nameDiv = document.createElement('div');
        nameDiv.className = "gh-hours-name";
        nameDiv.title = name;
        nameDiv.textContent = name;
        
        // Balken-Container
        const barWrapper = document.createElement('div');
        barWrapper.className = "gh-hours-bar-wrapper";
        
        // Fortschrittsbalken
        const bar = document.createElement('div');
        bar.className = "gh-hours-bar";
        bar.style.width = maxHours > 0 ? `${(hours / maxHours) * 100}%` : '0%';
        bar.style.backgroundColor = getEmployeeColor(name);
        
        // Stundenzahl
        const hoursLabel = document.createElement('div');
        hoursLabel.className = "gh-hours-value";
        hoursLabel.textContent = `${hours} Std`;
        
        // "King" Krone f√ºr den Spitzenreiter
        if (index === 0 && hours > 0) {
          const crown = document.createElement('div');
          crown.className = "absolute -top-3 right-0 text-lg";
          crown.textContent = "üëë";
          crown.title = "Meiste Arbeitsstunden";
          barWrapper.appendChild(crown);
        }
        
        barWrapper.appendChild(bar);
        barWrapper.appendChild(hoursLabel);
        
        barContainer.appendChild(nameDiv);
        barContainer.appendChild(barWrapper);
        chartContainer.appendChild(barContainer);
      });
      
      hoursContainer.appendChild(chartContainer);
      calendarContainer.appendChild(hoursContainer);
    }
  }
  
  // Toggle-Funktionalit√§t entfernt
  // const toggleButton = document.getElementById('toggleView');
  const calendarView = document.getElementById('calendar');
  
  generateCalendar(year, month, planData.assignments);

  // Funktion zum Schlie√üen des Popups
  function closeDayDetails() {
    const popup = document.getElementById('dayDetailsPopup');
    popup.classList.remove('active');
  }
  
  // Schlie√üen des Popups beim Klick auf den Hintergrund
  document.getElementById('dayDetailsPopup').addEventListener('click', function(event) {
    if (event.target === this) {
      closeDayDetails();
    }
  });
</script>
{% endblock %}
